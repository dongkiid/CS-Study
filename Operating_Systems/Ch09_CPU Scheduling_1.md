# CS 스터디 _ 반효경 _ 운영체제


목차
- 운영체제란?
- 컴퓨터시스템의 구조
- 프로세스 관리
- **CPU 스케쥴링**
- 병행 제어
- 데드락
- 메모리 관리
- 가상 메모리
- 파일 시스템
- 입출력 시스템
- 디스크 관리

---

# CPU 스케줄링 1

### CPU burst

프로세스가 CPU를 사용하여 실행되는 시간. CPU 버스트는 프로세스가 실행 상태에서 CPU를 활용하여 계산이나 연산 작업을 수행하는 시간.

사용자 프로그램이 CPU를 가지고 직접 빠른 명령을 수행하는 단계. 프로그램은 CPU내에서 일어나는 명령 (ex.Add)이나 메모리에 접근하는 일반 명령을(ex.store, Load) 사용할 수 있다.

### I/O burst

입출력(I/O) 작업을 수행하는 시간. 프로세스가 입출력 장치(예: 디스크, 네트워크 등)와 상호 작용하여 데이터를 읽거나 쓰는 작업을 수행하는 시간.

커널에 의해 입출력 작업을 진행하는 비교적 느린 단계이다. 이 단계에서는 모든 입출력 명령을 특권 명령으로 규정하여 사용자 프로그램이 직접 수행할 수 없도록 하고, 대신 운영체제를 통해 서비스를 대행하도록 한다.

⇒ 이처럼 사용자 프로그램은 CPU작업과 I/O 작업의 반복으로 구성된다. 그래서 CPU 스케줄링 알고리즘으로 CPU 버스트와 I/O 버스트의 교대로 인해 프로세스의 실행 시간 및 우선순위를 결정한다. 

### CPU bound process & I/O bound process

각 프로그램마다 CPU & I/O burst가 차지하는 비율이 균일하지 않다.

- I/O 바운드 프로세스

I/O 요청을 빈번하게 수행해 CPU 버스트가 짧게 나타나는 프로세스. 주로 사용자로부터 인터랙션을 계속 받아가며 프로그램을 수행하는 대화형 프로그램이 해당됨

- CPU 바운드 프로세스

I/O 요청을 거의 하지 않아 CPU 버스트가 길게 나타나는 프로세스. 주로 프로세스 수행 상당 시간을 입출력 작업없이 CPU작업에 소모하는 계산 위주의 프로그램이 해당됨 

### CPU 스케줄링

컴퓨터 시스템 내에서 수행되는 프로세스의 CPU 버스트를 분석해보면 대부분의 경우 짧은 CPU 버스트를 가지며, 극히 일부분만 긴 CPU 버스트를 갖는다. 이는 다시말해 CPU를 한번에 오래 사용하기보다는 잠깐 사용하고 I/O 작업을 수행하는 프로세스가 많다는 것이다. 즉, 대화형 작업을 많이 수행해야하는데 사용자에 대한 빠른 응답을 위해서는 해당 프로세스에 우선적으로 CPU를 할당하는 것이 바람직하다. 만약 CPU 바운드 프로세스에 CPU를 먼저 할당한다면, 그 프로세스가 끝날때까지 수많은 I/O 프로세스는 기다려야 할 것이다. 이러한 문제 때문에 CPU 스케줄링이 필요해졌다.

- CPU 스케줄러 필요한 경우
    1. Running → Blocked: 프로세스가 실행 중인 상태에서 I/O 요청과 같은 외부 이벤트가 발생하는 경우, 프로세스는 블록 상태로 전환되어 해당 이벤트의 완료를 기다림. 이때 CPU 스케줄러는 다른 준비된 프로세스에게 CPU를 할당하여 작업을 수행하도록 전환.
    2. Running → Running: 할당된 CPU 시간이 만료되는 경우, 스케줄러는 실행 중인 프로세스를 중단하고 다른 준비된 프로세스로 전환. 이는 할당된 시간 내에 작업을 완료하지 못한 경우나, 다른 프로세스에게 CPU 사용 기회를 주기 위해 필요한 상황.
    3. Blocked → Ready: I/O 완료나 타이머 인터럽트 등의 이벤트가 발생하여 블록된 프로세스가 다시 실행 가능한 상태가 되는 경우, 스케줄러는 해당 프로세스를 준비된 상태로 전환하여 CPU를 할당할 수 있도록 함.
    4. Terminated: 프로세스의 실행이 완료되고 종료된 경우, 스케줄러는 해당 프로세스를 제거하고 다음 실행할 프로세스를 선택하는 역할을 수행.
    
    1,4번째 스케줄링: non-preemptive
    
    2,3번째 스케줄링: preemptive
    
    - 3번째 스케줄링: Context Switch가 발생할 때만 해당
    

### Dispatcher

CPU를 누구한테 줄 지 결정했으면 해당 프로세스에게 넘겨야 하는데, 디스패처가 이 역할을 함. 이 과정이 Context Switch에 해당 

### 스케줄링의 성능 평가 (Scheduling Criteria)

시스템 입장

- CPU utilization(이용률)
    - 전체 시간 중 CPU가 일을 한 시간의 비율
- Thoughput(처리량)
    - 주어진 시간동안 준비 큐에서 기다리고 있는 프로세스 중 몇개를 끝마쳤는 지 나타냄

프로세스 입장

- Turnaround time (소요 시간, 반환 시간)
    - 프로세서가 CPU를 요청한 시점부터 자신이 원하는 만큼 CPU를 다 쓰고 CPU 버스트가 끝날 때 까지 걸린 시간
- Waiting time (대기 시간)
    - CPU 버스트 기간 중 프로세스가 준비 큐에서 CPU를 얻기 위해 기다린 시간의 합
- Response time (응답 시간)
    - 프로세스가 준비 큐에 들어온 후 첫 번째 CPU를 획득하기까지 기다린 시간
        - 대화형 시스템에 적합한 성능 척도로서, 사용자 입장에서는 가장 중요한 성능 척도

### 생활 속 비유

- 중국집에 주방장과 손님이 있다.
- 이용률, 처리률 → 중국집 입장에서의 척도
    - 이용률: 전체 시간 중 주방장이 일한 시간의 비율
    - 처리률: 주방장이 정해진 시간 동안 요리를 만들어 준 손님의 수
- 소요 시간, 대기 시간, 응답 시간 → 손님 입장에서의 척도
    - 소요 시간: 손님이 중국집에 들어와서 주문한 음식을 다 먹고 나가기까지 소요된 총 시간
    - 대기 시간: 음식을 먹은 시간을 제외한 순수하게 기다린 시간 (음식이 조금씩 여러 번 나왔더라도 중간 중간 기다린 시간을 다 합쳐야 함)
    - 응답 시간: 최초의 음식이 나오기까지 기다린 시간
    

### 스케줄링 알고리즘

**선입선출 스케줄링 (비선점)**

- 먼저 온 순서대로 처리하는 방식
- CPU를 오래 쓰는 프로세서가 먼저 와서 쳬ㅕ를 할당 받으면, 나머지 프로세스들은 전부 기다려야하므로 효율적이지 않음 ( 긴 프로세스 하나 때문에 짧은 프로세스 여러개가 기다리는 현상은 convoy effect라고 부름 )
    
    ⇒ 어떤 프로세스가 먼저 실행되느냐에 따라 대기 시간에 상당한 영향을 미침 
    

**최단 작업 우선 스케줄링 (선점, 비선점)**

- CPU 버스트가 가장 짧은 프로세스에 CPU를 먼저 할당하는 방식
- 평균 대기시간을 가장 짧게 하는 최적 알고리즘
- 문제점
    - Starvation(기아 현상): 짧은 프로세스로 인해 긴 프로세스가 영원히 CPU를 할당받지 못할 가능성이 있음
    - CPU 버스트 시간을 미리 알 수 없음: 과거 CPU 사용 시간을 통해 추정만 가능

**우선순위 스케줄링(선점, 비선점)**

- 우선운위 값이 작을 수록 높은 우선 순위를 가짐
- SJF는 일종의 우선 순위 스케줄링이라고 볼 수 있음 (우선 순위 = 예상되는 다음 CPU 버스트 시간)
- 문제점
    - Starvation(기아 현상): 짧은 프로세스로 인해 긴 프로세스가 영원히 CPU를 할당받지 못할 가능성이 있음
    
    ⇒ 해결 방안: Aging(노화): 아무리 우선 순위가 낮은 프로세스라 하더라도 시간이 오래 지나면 우선 순위를 높여주는 기법
    

**라운드로빈 스케줄링**

- 각 프로세스는 동일한 크기의 시간 할당량 (time quantum)을 가지고, 할당 시간이 지나면 프로세스는 CPU를 빼앗기고 Ready Queue 맨 뒤에 가서 줄을 섬
- 짧은 응답 시간 보장
    - CPU를 일정시간 동안 줬다 뺏다를 반복하기 때문에 CPU를 최초로 얻기까지 걸리는 시간이 짧음
- 시간 할당량이 커질 수록 선입선출식 알고리즘에 가까워짐
- 시간 할당량이 작을 수록 문맥 교환이 빈번해져 오버헤드가 증가함
- 일반적으로 SJF보다 평균 소요시간이 길지만, 응답시간은 짧음
- 시간이 오래 걸리는 job과 그렇지 않은 것들이 섞여있을 때는 효율적이지만, 모든 시간이 비슷한 job만 있을 경우 비효율적