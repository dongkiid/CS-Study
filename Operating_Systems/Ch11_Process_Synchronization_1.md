프로세스는 병렬로 실행될 수 있으며, 데이터를 공유할 수 있다. 만약 여러 개의 프로세스가 같은 자원을 동시에 접근하게 된다면 어떻게 될까? 충돌이 발생할 수 있을 것이다.

예를 들어, count 라는 변수에 5라는 값을 초기화를 했다.

Process A는 `count++` 연산을, Process B는 `count--` 연산을 병행하여 실행한다면? count의 값은 4, 5, 6 중 하나의 값으로 명확하지 않게 되는 것이다.

이와 같이 동시에 여러 개의 프로세스가 동일한 자료를 접근해 조작하게 되고  그 실행 결과가 접근이 발생한 특정 순서에 의존하는 상황을 `경쟁 상황(Race Condition)` 이라고 한다.

경쟁 상황으로부터 보호하기 위해서는 한 순간에 하나의 프로세스만이 자료에 접근하고 조작이 가능하도록 보장해줘야 하는 것이다. 

이를 위해 문제를 해결하는 것이 바로 프로세스 동기화(Process Synchronization) 이다.

# Process Synchronization

프로세스 동기화에서 중요한 문제 중 하나는 임계구역(Critical Section) 문제이다.

### Critical Section이란?

한글로 `임계구역`이라 부르고, 여러 개의 프로세스가 수행되는 시스템에서 각 프로세스들이 공유하는 데이터(변수, 테이블 파일 등)를 작업하는 코드 영역이다.

### Process의 일반적인 구조

![image](https://github.com/IToriginal/CS-Study/assets/117193889/64a48ffd-f338-4935-994d-8730c2c62a20)


프로세스의 일반적인 구조는 크게 4가지 부분으로 나뉜다.

[1] Entry section

- 임계 영역에 진입하기 위해 진입 허가를 요청하는 부분

[2] Critical section

[3] Exit section

- 임계 영역에서 나오기 위한 퇴출 구역

[4] Remainder section

- 나머지 구역

[1], [3] section은 중요한 부분이다. 이 부분에 적절한 알고리즘을 활용해 임계영역 문제를 해결하기 때문이다.

### 임계영역 문제

임계영역 문제는 지정되어야 할 코드 영역이 임계 영역으로 지정되지 않았을 때 발생할 수 있는 문제를 의미한다.

이 문제를 해결하기 위해서는 아래의 세가지 요구 조건을 충족해야 한다.

**[1] Mutual Exclusion (상호 배제):**

프로세스 P가 자기의 임계영역에서 실행 중이라면, 다른 프로세스들은 임계영역에 접근할 수 없다.

**[2] Progress (진행):**

아무도 임계구역에 있지 않은 상태에서 임계구역에 들어가고자 하는 프로세스가 있다면, 임계구역에 들어가게 해줘야한다.

**[3] Bounded Waiting (유한 대기)**

프로세스가 자기의 임계구역에 진입하려는 요청을 한 후부터 그 요청이 허용될 때까지 다른 프로세스들이 그들 자신의 임계구역에 진입하도록 허용되는 횟수에 한계가 있어야 한다. (쉽게 말해서 지나치게 기다리는 경우가 없도록 하는 것)

그렇다면 이러한 문제를 해결하기 위한 해결책은 뭘까?

# 임계영역 문제를 해결하기 위한 해결책

## 소프트웨어 기반: 피터슨의 해결안(Peterson’s Solution)

피터슨의 해결안은 임계영역과 나머지 구역을 번갈아 가며 실행하는 두 개의 프로세스로 한정된다. 또한, 두 개의 변수를 공유하도록 하여 임계영역의 문제를 해결한다.

![image](https://github.com/IToriginal/CS-Study/assets/117193889/95d8e921-34c4-492a-975a-435a95cdcd48)

위의 변수를 활용한 프로세스 i의 구조는 아래와 같다

![image](https://github.com/IToriginal/CS-Study/assets/117193889/5b53caa2-9ecb-4ed2-86cc-199af65338e6)


코드를 살펴보면 프로세스 i가 임계영역으로 진입할 준비가 되어있어도 while문을 통해 프로세스 j가 아직 임계영역에서 작업 중이라면 진입을 못하도록 되어있다. 후에 프로세스 j가 작업을 마치고 flag[i]를 false로 바꾸면 프로레스 i가 임계구역에 진입하도록 한다.

피터슨의 해결안은 임계영역 문제를 해결해주는 좋은 방법이지만, 현대 컴퓨터 구조에서 올바르게 동작하는 것을 보장하지 않는다. 
이를 위해 하드웨어에서부터 소프트웨어 기반으로 해결하는 방법은 동기화 하드웨어이다.

## 하드웨어 기반: 동기화 하드웨어(Synchronization Hardware)

임계영역 문제는 단일 처리 환경에서는 공유 변수가 변경되는 동안 인터럽트 발생을 허용하지 않음으로서 간단히 해결이 가능하지만, 다중 처리 환경에서는 적용할 수 없다.

다중 처리 환경상에서 인터럽트의 사용 불가능은 메시지가 모든 처리에 전달되게 하기 때문에 상당한 시간을 소비해 시스템 효율을 떨어뜨리기 때문이다.

많은 현대의 하드웨어는 한 워드(word)의 내용을 검사하고 변경하거나, 두 워드의 내용을 원자적(Atomically)으로 교환(Swap)할 수 있다. 즉, 인터럽트 되지 않는 하나의 단위로서, 특별한 하드웨어 명령어를 제공하는데, 이 명령어들을 사용해 임계영역 문제를 상대적으로 간단한 방식으로 해결이 가능한 것이다.

### test_and_set()

이 명령어의 중요한 특징은 원자적(Atomically)으로 실행된다는 점이다.

![image](https://github.com/IToriginal/CS-Study/assets/117193889/7ca8c265-a395-41dd-adb3-f1f4b69fbdcf)

그리고, test_and_set() 명령어를 사용한 상호 배제 구조는 아래와 같은데 lock이라는 공유 변수를 사용해 **[1] Mutual Exclusion (상호 배제)** 를 해결한다.

![image](https://github.com/IToriginal/CS-Study/assets/117193889/193caa45-2728-4756-87ca-8f2accb9e57f)

### compare_and_swap()

test_and_set() 명령어와는 대조적으로 세 개의 피연산자를 인자로 전달받는 것이다.

![image](https://github.com/IToriginal/CS-Study/assets/117193889/9ed72d0b-bf26-4301-94fa-bf797870b484)

아래의 구조를 살펴보면, test_and_set()과 마찬가지로 lock이라는 공유 변수를 통해서 **[1] Mutual Exclusion (상호 배제)** 를 해결한다.

![image](https://github.com/IToriginal/CS-Study/assets/117193889/96ec7e42-9540-494b-8424-6053c121a35a)

위 두 알고리즘은 `lock`이라는 공유 변수를 활용하여 임계구역의 사용 유무를 판단하여 프로세스 간의 문제를 해결한다. 하지만 **[3] Bounded Waiting (유한 대기)** 을 만족시키지 못한다.

### 그렇다면 이 문제들을 어떻게 해결할 수 있다는 것일까?

임계영역 문제의 요구 조건을 모두 만족시키는 test_and_set() 명령어를 이용한 또다른 알고리즘이 있는데 **[3] Bounded Waiting (유한 대기)** 조건 또한 만족시키기 위해서 아래의 공유 변수 두 가지를 추가적으로 사용하는 것이다.

![image](https://github.com/IToriginal/CS-Study/assets/117193889/38264482-bf54-4fa2-a710-ddae7c905f5d)

그렇다면, 위의 변수를 추가로 사용해 모든 조건을 만족시키기 위한 코드는 아래와 같다.

![image](https://github.com/IToriginal/CS-Study/assets/117193889/fd8843f9-da32-4120-9f60-24b0bf646123)

코드를 살펴보면 한 프로세스가 임계영역을 탈출할 경우 임계영역에 들어가고자 하는 프로세스는 waiting 배열을 순환하다 자신이 while문의 조건을 성립할 때 임계영역에 진입을 하게 된다. 최대 n-1회만 양보하면 자신의 차례가 와서 진입이 가능하기 때문에 **[3] Bounded Waiting (유한 대기)** 조건을 만족하여 문제를 해결할 수 있는 것이다.

하지만, 이 방법들은 복잡할뿐만 아니라 응용프로그래머는 사용하는데 어려움이 있었고, 이를 위해서 운영체제 설계자들은 임계영역 문제를 해결하기 위한 소프트웨어 도구들을 개발했다.

그 중에서 가장 간단한 도구가 바로 `mutex` 락이다.

# 임계영역 문제를 해결하기 위한 또 다른 방법

## [1] mutex

mutex 락 역시 lock을 사용하는 방법으로 프로세스는 임계영역에 들어가기 전에 반드시 lock을 획득해야 하고 임계영역을 빠져나올 때는 lock을 반환해야 한다. mutex 락은 available이라는 변수를 사용해 lock의 가용 여뷰를 표시하게 된다.

### mutex 락을 사용하는 프로세스 구조

acquire() 메서드를 통해 lock을 획득하고 release()메서드를 통해 lock을 반환한다.

![image](https://github.com/IToriginal/CS-Study/assets/117193889/ea5b0348-0028-4493-aa18-785b7e16c839)

acquire() 메서드와 release() 메서드는 아래와 같다.

![image](https://github.com/IToriginal/CS-Study/assets/117193889/f6ce4075-6deb-4de1-8ea8-38e293955381)

지금까지 설명한 동기화 하드웨어의 방법들의 단점은 **바쁜 대기(Busy Waiting)** 을 해야 한다는 것이다.

프로세스가 임계영역에 있는 동안 임계영역에 들어가기 원하는 다른 프로세스들은 `acquire()` 메서드를 호출하는 반복문을 계속 실행해야 하기 때문인데, lock이 가용해지기를 기다리면서 프로세스가 계속 회전을 하고 있기 때문에 **`spinlock`** 이라고 부른다.

**바쁜 대기(Busy Waiting)** 는 다른 프로세스가 더 생산적인 작업에 사용할 수 있었던 CPU 사이클을 낭비하게 된다.

하지만 lock을 기다리는 동안 상당한 시간을 소모하는 문맥 교환을 전혀 필요로 하지 않는 장점도 있기 때문에 프로세스들이 짧은 시간 동안만 lock을 소유할 것이라고 예상되면 `spinlock`이 유용하다.