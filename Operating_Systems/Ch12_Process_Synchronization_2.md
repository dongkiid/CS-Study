mutex 락과 유사하게 동작하지만 프로세스들이 자신들의 행동을 더 정교하게 동기화할 수 있는 방법인 **세마포어(Semaphore)** 에 대해서 알아보자.

## [2] 세마포어(Semaphore)

### 세마포어 란?
> 공유된 자원의 데이터 혹은 임계영역(Critical Section) 등에 여러 Process 혹은 Thread가 접근하는 것을 막아주는 것

이진(Binary) 세마포어와 카운팅(Counting) 세마포어가 존재한다.

이진 세마포어는 mutex 락과 유사하며 0과 1사이의 값만 가능하다. 반면,

카운팅 세마포어는 제한 없는 영역(Domain)을 가지게 되고 가용한 자원의 개수로 초기화한다.

각 자원을 사용하려는 프로세스는 세마포어에 wait() 연산을 수행하며, 세마포어 값을 -1만큼 감소시킨다. 반대로 자원을 반환할때는 signal() 연산을 수행해 세마포어 값은 +1 만큼 증가시킨다. 이를 통해서 세마포어 값이 0이 되면 모든 자원이 사용 중임을 알 수 있는 것이다.

### 각 메서드들의 구조

![image](https://github.com/IToriginal/CS-Study/assets/117193889/0b73ea0b-366f-4875-901c-2b4803a5fb8c)

하지만, 이 방법도 마찬가지로 Busy Waiting 문제가 발생하게 된다.

이를 해결하기 위해서 세마포어 연산의 정의를 변경한다.

프로세스가 wait() 연산을 실행하고 세마포어 값이 양수가 아닌 것을 발견한다면, 프로세스는 반드시 대기해야 한다.

이때 Busy waiting 대신 자신을 봉쇄할 수 있도록 한다. 봉쇄 연산은 프로세스를 세마포어 연관된 대기 큐에 넣고, 프로세스의 상태를 대기 상태로 전환한다. 그 후에 제어가 CPU 스케줄러로 넘어가고, 스케줄러는 다른 프로세스를 실행하기 위해 선택한다.

세마포어 S를 대기하면서 봉쇄된 프로세스는 다른 프로세스가 signal() 연산을 실행하면 wakeup() 연산을 통해 재시작되도록한다.

### 개선된 세마포어의 구조

![image](https://github.com/IToriginal/CS-Study/assets/117193889/41b5d4b2-268b-4158-9981-2d8de819c47c)

먼저 세마포어를 구조체를 이용해 위와 같이 정의한다.

각 세마포어는 한 개의 정수 value와 프로세스 리스트 list를 가진다. 프로세스가 세마포어를 기다려야 한다면, 이 프로세스를 세마포어의 프로세스 리스트에 넣어준다.

![image](https://github.com/IToriginal/CS-Study/assets/117193889/3f95f910-1fbf-4d06-aa34-034eb6149e02)

이후 signal() 메서드를 통해서 프로세스 리스트에서 한 프로세스를 꺼내서 그 프로세스를 깨워준다.

![image](https://github.com/IToriginal/CS-Study/assets/117193889/ebde7775-2883-47de-9b3a-bdb9bb4a4169)

이 방법 또한 Busy waiting을 완벽히 해결한 것은 아니다. 하지만, Busy waiting을 진입 코드에서 응용 프로그램의 임계영역으로 이동하였다.

또한, Busy waiting을 wait()와 signal() 메서드들의 임계 영역에만 국한시켜 이 영역은 매우 짧다. 그래서 임계 영역은 거의 항상 비게 되고, Busy waiting은 드물게 발생하게 된다. 만약 발생하게 되더라도 그 시간이 매우 짧다.

다만, 임계영역이 매우 길거나 거의 항상 점유되어 있는 응용프로그램들을 갖는 상황에는 Busy waiting은 비효율적이게 된다.

## [3] Monitors

마지막으로 모니터(Monitors)이다. 세마포어를 활용해 임계영역 문제를 해결할 수 있었지만 프로그래머가 세마포어를 잘못 사용하게 되면 다양한 유형의 오류가 너무 쉽게 발생하게 된다. 이러한 동기화 문제를 해결하기 위해 나온 것이 Monitors이다.

세마포어가 low level language 방식이었다면 모니터는 high level language 방식이라 볼수 있다.

### 모니터의 구조

![image](https://github.com/IToriginal/CS-Study/assets/117193889/81fc0e00-06c7-4ce5-bc8a-b7f5012d1dd1)

모니터의 동작원리는 다음과 같다.

어떤 공유 데이터에 대해 모니터를 지정해두면, 프로세스는 그 데이터를 접근하기 위해 모니터에 들어가야만 한다. 즉, 모니터 내부에 들어간 프로세스에만 공유데이터를 접근할 수 있는 기능을 제공하는 것이다. 또한 프로세스가 모니터에 들어가고자 할 때는 다른 프로세스가 모니터 내부에 있다면 입장 큐에서 기다려야 한다.

세마포어의 동기화 오류를 모니터는 프로시저를 호출해서 해결할 수 있는 것이다.