
# 데드락

### DeadLock

= 교착 상태, 오버헤드가 큰 작업

일련의 프로세스들이 일부 자원을 가지고 있으면서, 서로가 가진 자원을 요구하며 block된 상태로 무한 대기에 빠진 상황.

### 데드락 발생 조건

1. 상호 배제 : 한번에 프로세스 하나만 해당 자원을 사용할 수 있음. 다른 프로세스는 요청된 자원이 해제될 때 까지 대기
    - 식사하는 철학자 : 철학자가 젓가락 1개 들고 있으면 다른 이는 그 젓가락을 사용할 수 없음
2. 점유 대기 : 자원을 가진 프로세스가 다른 자원을 기다릴 떄 보유 자원을 놓지 않음
    - 철학자가 다른 한 쪽 젓가락을 기다릴 때, 들고 있는 젓가락을 놓지 않음
3. 비선점 (No preemtive) : 한 프로세스가 자료를 사용하는 중에는 커널이 빼앗아서 다른 프로세스에 배분할 수 없음
    - 철학자가 집어든 젓가락은 다른 철학자가 빼앗을 수 없음
4. 원형 대기 : 프로세스가 요구하는 자원의 방향이 사이클을 형성
    - 모든 철학자가 왼쪽 젓가락부터 집어드는 상황이라면 사이클을 형성해 서로 점유한 자원을 요청

⇒ 위 네가지 조건을 성립해야만 비로소 교착 상태의 발생 확률이 존재 (조건을 다 만족하더라도 드물게 발생)

- 컴퓨터 환경에 치명적이고. 교착상태에 의한 오류는 해결이 힘든 편이다

### 자원 할당 그래프

시스템 내의 자원과 프로세스 간의 할당 관계를 그래프로 표현하고, 사이클이 발생하지 않도록 한다. 사이클이 없는 자원 할당 그래프는 데드락을 방지할 수 있다.

<img src="https://github.com/kkkwp/CS-Study/assets/113974911/24bab3dd-931f-4926-904e-d30b84ec46f2" >


위 그래프를 살펴 보면 아래와 같다.

- P1은 R2의 자원을 점유하고 R1의 자원을 대기 중이다 - 점유 대기(Hold and wait)
- P2는 R1과 R2의 자원을 점유하고 R3의 자원을 대기 중이다 - 점유 대기(Hold and wait)
- P3은 R3의 자원을 가지고 있지만 아무런 추가 자원을 요청하지 않는다.

P1과 P2는 점유 대기 상태에 있지만 P3가 아무런 자원을 요청하지 않고 있으므로 순환 대기(Circular wait) 상태가 아니다. 그래서 위 상황은 데드락 상태가 아니다.

<img src ="https://github.com/kkkwp/CS-Study/assets/113974911/1ffb1dff-d9b4-4cf5-beba-e2a3330cf511" >

P3은 R2의 자원을 요청했으나 R2는 이미 할당 할 수 있는 자원을 모두 사용 했으므로, P3은 대기 상태에 빠지게 된다. 여기서 R2는 P2에게 할당 되었고, P2는 R3을 기다리고 있다. 하지만 R3은 이미 P3에게 할당 되어 있어 순환 대기 상태에 빠지게 되었다. 데드락이 발생한 것이다!!! 

# 데드락 처리 방법

- 데드락  발생 하지 않도록 예방 (Prevention)
- 데드락 발생 가능성 인지 후 적절히 회피 (Avoidance)
- 데드락 발생을 허용하나 데드락을 탐지(Detection)하여 복구 (Recovery)

### 데드락 예방

- 데드락 발생조건 4가지중 하나라도 발생하지 않으면 데드락이 발생하지 않으므로 각 조건을 부정하여 발생 가능성 차단
- 상호 배제 해결 : 공유 불가능한 상태 해제 시 동시성 문제가 발생할 여지가 있어 현실적으로 불가능
- 점유 대기 해결 : 자원을 가진 상태에선 다른 자원을 기다리게 하지 않는 방법으로, 여러 자원이 필요하다면 모든 자원을 얻을 수 있는 경우에만 자원을 요청하여 일부만 얻을 시 반납 ( 자원의 활용률과 성능이 저하되고 starvation이 발생할 수 있음)
- 비선점 해결 : 요청 대기 상태에 빠지는 프로세스의 모든 자원을 암묵적으로 해제(Release)하도록 요철 프로세스가 가진 자원을 전부 선점으로 바꾸는 방법. 이러면 CPU는 문제가 없겠지만 프린트 등을 선점할 수 없는 장치를 스위칭하면 곤란할 수 있음. 이 방식은 save&restore 가능한 자원에서만 가능.
- 순환 대기 해결 : 앞의 세가지보다 적용할 여지가 있음. 모든 자원에 번호를 매기고 오름차순으로 자원을 요청하는 등 한쪽 방향으로만 자원 요구. 이 역시 자원의 활용률 저하 문제가 있긴 함

⇒ 4가지 조건을 하나만 부정하려 해도 비용이 발생하기에 데드락으로 인한 비용보다 시스템 저하 비용이 작은 군사, 의료, 항공 우주등의 분야에서나 사용함이 좋음

### 데드락 회피

교착상태 회피 : 데드락을 **자원 요청에 대한 잘못된 승인**에서 기인한다고 판단해 데드락을 방지하는 전략 

- 자원 요청에 대한 잘못된 승인 : 점유와 대기조건 관련

⇒  안전한 할당을 통해 원형 대기를 회피해야 한다. 불완전한 할당은 데드락 발생의 가능성이 있다.

- 안정 상태 : 프로세스들이 요청하는 모든 자원을 데드락 없이 차례대로 모두에게 할당할 수 있는 상태
- 불안정 상태 : 데드락 발생 가능성이 존재하는 상황
- 안전 순서 : 자원 할당, 실행, 종료 시 데드락이 발생하지 않는 순서
    - 사이클이 없음을 의미
    - 단점: 구현 시 할당 가능,이용 가능한 자원의 수와 프로세스가 요구하는 자원의 수 등 사전 정보를 요구
- 은행원 알고리즘
    
    자원의 타입이 여러개인 경우 사용, 프로세스가 자원을 요구할 때 자원을 할당한 뒤 안정 상태로 남게 되는 지 사전에 검사하여 교착상태 회피
    
    - 단점 : 할당하는 자원이 일정하고 최대 자원 요구량을 알아야하며 항상 불안정 상태를 회피해야하므로 자원 이용률이 낮다
    
   <img src ="https://github.com/kkkwp/CS-Study/assets/113974911/8c5564dc-47d7-4d7a-8e20-b9ee0e438a02">
    
    - 12개의 자원으로 할당을 시작한다고 하자.
        1. 첫 할당 시 각 프로세스에 5 + 2 + 2 = 9만큼의 자원을 할당하여 3이 남음
        2. P0는 5를 요구하기에 skip하고 P1이 2를 요구하여 2를 할당한 뒤 1이 남음
        3. P1이 필요한 자원을 모두 받고서 반납한 결과 5가 남게되고 P0에게 할당
        4. P0이 필요한 자원을 모두 받고서 반납한 결과 10이 남고 P2에게 할당
        5. 무사히 데드락 없이 자원 배분을 종료
        - 만약 P2가 처음에 2가 아니라 3을 받았다면 P1이 작업을 끝내고 4만 남아 P0과 P2는 데드락에 걸린다.

### 데드락 검출 및 복구

- 교착 상태가 일어나는 것을 허용, 단 OS가 주기적으로 교착상태 발생 여부를 검사하기 위해 탐지 알고리즘을 수행하고, 만약 이 과정에서 교착 상태가 발견되면 이를 회복하는 알고리즘을 수행
    - 탐지 주기가 짧으면 오버헤드가 커짐
    - 탐지 주기가 길면 복구 가능성 낮아짐
- 탐지 알고리즘
    - Single Instance : 자원 할당 그래프 알고리즘 이용
        
        <img src ="https://github.com/kkkwp/CS-Study/assets/113974911/830bb0a3-6e45-4112-a04a-2b4b9d40968d">
        
        실선은 요청을 한 것 / 점선은 미래에 요청할 가능성이 있는 것으로, 
        
        생성된 그래프에서 싸이클을 탐지하고 싸이클이 존재한다면 데드락 상태인지 판별 
        
    
    - Multiple Instance : 은행원 알고리즘 과 비슷한 방법 (Allocation, Request, Available)
        - 은행 알고리즘과 차이점
            - 프로세스가 사용할 자원의 최대 개수를 미리 알지 못함
            - 자원을 할당한 후 상태를 검사하는 것이 아닌 현재 상태를 검사해 교착 상태를 탐지
        - Allocation : 행렬 또는 데이터 구조로 어떤 프로세스가 어떤 자원을 할당받았는 지 기록
        - Request : 자원 요청 시 할당 가능 여부 확인 (자원 사용 가능 여부 / 기다리고 있는 다른 프로세스 여부)
        - Available : 사용 가능한 자원의 현재 상태를 추적하는 메모리 공간 또는 데이터 구조 ( 알고리즘을 이용해서 사용 가능한 자원을 기반으로 요청을 처리하고 할당 가능여부를 결정)
    
    ⇒ 데드락 탐지는 데드락 상태를 정확하게 탐지할 수 있지만, 그 자체로는 데드락을 해결하지 않는다. 그래서 교착 상태에 빠졌을 때 복구를 해야한다.
    
- 복구(회복)
    - process termination : 한번에 모든 프로세스 혹은 한개 씩 종료
        - 한번에 데드락 걸린 모든 프로세스 중단: 연산 중이던 프로세스 모두 일시 중단 되어 중간 결과가 폐기 됨
        - 하나 씩 중단 시키며 탐지 알고리즘으로 데드락 탐지/회복 : 오버헤드 문제
    - resource Preemption(자원 선점) : 선점 비용이 최소인 victim 프로세스를 선택해 자원 뺏어버리고 교착 상태가 해결될 때 까지 다른 프로세스에게 준다

### 데드락 무시

- 교착 상태 필요조건 4가지를 충족해도 데드락은 드문 현상임에 착안
- 드물게 발생하는 데드락을 처리하기 위한 비용은 비효율적이라 판단해 데드락에 아무런 조치도 하지 않음
- 시스템에서 데드락이 발생한 경우 프로그래머가 직접 프로세스를 죽이는 행위로 대응