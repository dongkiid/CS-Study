# Memory Management 3 & 4

## 1. Multilevel Paging and Performance (다단계 페이징 기법)

- 프로세스의 주소 공간이 더 커지면 다단계 페이지 테이블이 필요 -> 주소 변환을 위한 메모리 공간 낭비가 심해짐
- TLB(주소 변환을 용이하게 해주는 캐시 메모리)를 통해 메모리 접근 시간을 줄일 수 있다.
- 4단계 페이지 테이블을 사용하는 경우
    - 메모리 접근 시간이 100ns, TLB 접근 시간이 20ns
    - 요청된 페이지에 대한 주소 변환 정보가 TLB에 존재할 확률 98%인 경우 평균 메모리 접근 시간 (EAT) = 0.98 x 120 + 0.02 x 520 = 128ns
        - TLB hit이 성공할 때는 TLB 접근 시간과 메모리 접근 시간의 합인 120ns가 된다.
        - TLB hit이 실패할 때는 TLB 접근 시간과 메모리 접근 시간 x 5의 합인 520ns이 된다.
    - 결과적으로 주소 변환을 위해서만 28ns가 소요된다.

## 2. Memory Protection
- page table의 각 entry마다 아래의 bit를 둠
1. Protection bit
- page에 대한 접근 권한 (read/write/read-only)
2. Valid-invaild bit
- "valid"는 해당 주소의 frame에 그 프로세스를 구성하는 유효한 내용이 있음을 뜻함(접근 허용)
- "invalid"는 해당 주소의 frame에 유효한 내용이 없음을 뜻함(접근 불허)
  - 유효한 내용이 없다는 의미는 프로세스가 그 주소 부분을 사용하지 않고 있거나, 해당 페이지가 메모리에 올라와 있지 않고 swap area(backing store)에 임시 저장되어 있는 경우를 뜻함
  
![image](https://github.com/jooh9992/CodingTest/assets/54580802/c13520f5-9df1-4ee3-9c54-991899978f13)


## 3. Inverted Page Table (역페이지 기법)

- Page table이 매우 큰 이유
    - 모든 프로세스별로 모든 페이지에 대한 page table entry 존재
    - 대응하는 page가 메모리에 있든 아니든 간에 page table에는 entry로 존재하여 공간 오버헤드가 큰 편
    
- inverted page table
    - 페이지 프레임 하나당 페이지 테이블에 하나씩의 entry를 둔 것 (system-wide)
    - 논리적 주소에 대해 페이지 테이블을 만드는 것이 아니라, 물리적 주소에 대해 페이지 테이블을 만드는 것
    - 페이지 테이블의 각 항목은 어느 프로세스의 어느 페이지가 이 프레임에 저장되었는지의 정보를 보관
        - 페이지 테이블의 각 항목은 프로세스 번호(pid)와 그 프로세스 내의 논리적 페이지 번호(p)를 담고 있다.
    - 단점: 테이블 전체를 탐색해야 함 (시간적인 오버헤드 존재)
    - 해결 방법: associative register(연관 레지스터)를 사용하여 병렬 탐색을 수행 -> 별도의 하드웨어를 사용하여 시간적인 오버헤드를 줄이는 방법

![image](https://github.com/jooh9992/CodingTest/assets/54580802/1daa1856-39ab-4488-8f3e-276622eca060)


## 4. Shared Page (공유 페이지)

- Shared code (= Re-entrant Code, 재집입 가능 코드, 순수 코드)
  - read-only로 하여 프로세스 간에 하나의 code만 메모리에 올림 (코드 공유)
  - 공유 코드는 모든 프로세스의 logical address space에서 동일한 위치에 있어야 함

- Private code and data
  - 각 프로세스들은 독자적으로 메모리에 올림
  - Private data는 logical address space의 아무곳에 와도 무방
  - ex) 하나의 워드 프로그램 3개를 사용한다고 하면, 같은 프로그램을 사용하기 때문에 프로그램 코드는 share가 가능함. 이렇게 share가 가능한 코드들에 대해서는 물리적 메모리에 하나의 코드만 올려서 공유함. 각각의 프로세스마다 다른 데이터 코드만 메모리에 별도로 올려서 사용

![image](https://github.com/jooh9992/CodingTest/assets/54580802/d0956e2d-53c9-45cf-8bdf-884acc5bcf0b)
- ed 1, ed 2, ed 3는 공유 페이지이고, data 1, data 2, data 3는 사유 페이지이다.

---
<br/>

# 세그먼테이션

- 프로그램은 의미 단위인 여러 개의 segment로 구성
    - 작게는 프로그램을 구성하는 하나 하나를 세그먼트로 정의
    - 크게는 프로그램 전체를 하나의 세그먼트로 정의 가능
    - 일반적으로는 code, data, stack 부분이 하나씩의 세그먼트로 정의됨
- 세그먼트는 다음과 같은 logical unit이라 할 수 있음
    - main()
    - function
    - global variables
    - stack
    - symbol table
    - arrays
    - ...

![image](https://github.com/jooh9992/CodingTest/assets/54580802/8a6ee56b-eaeb-444d-9455-9c0dc65d9519)

## 1. 세그먼테이션 기법

- Logical address는 <세그먼트 번호(s), 오프셋(d)>으로 구성
    - 세그먼트 번호는 해당 논리적 주소가 프로세스 주소 공간 내에서 몇 번째 세그먼트에 속하는 지를 나타냄
    - 오프셋은 그 세그먼트 내에서 얼마만큼 떨어져 있는 지에 대한 정보를 나타냄
- 세그먼테이션 테이블을 사용 (주소변환이 필요하므로 테이블 존재)
    - 기준점(base)과 한계점(limit)을 가짐
    - 기준점은 물리적 메모리에서 그 세그먼트의 시작 위치를 나타내고, 한계점은 그 세그먼트의 길이
- 세그먼트 테이블 기준 레지스터(STBR)와 세그먼트 테이블 길이 레지스터(STLR)을 사용
    - STBR은 현재 CPU에서 실행 중인 프로세스의 세그먼트 테이블이 메모리의 어느 위치에 있는지 그 시작 주소를 담고 있음
    - STLR은 그 프로세스의 주소 공간이 총 몇 개의 세그먼트로 구성되는지, 즉 세그먼트의 크기를 나타냄

![image](https://github.com/jooh9992/CodingTest/assets/54580802/a19c4407-fb7a-4688-9aad-bf481f6714e6)

    

## 2. 세그먼테이션 하드웨어

- 프레임의 크기가 일괄적인 페이징 기법과 달리, 세그먼트 기법은 unit별로 크기가 다르기 때문에 물리적 메모리에서 세그먼트가 시작하는 위치인 base와 함께 세그먼트의 크기인 limit 값도 가지고 있음
- 페이징에서는 프레임 크기가 모두 동일하기 때문에 프레임 번호만으로도 주소를 찾아갈 수 있음
- 주소 변환 시 확인해야할 것은 세그먼트 번호가 STLR보다 작아야 하고, 세그먼트의 크기 limit보다,
세그먼트가 위치하는 곳을 나타내는 offset의 크기 d의 값이 더 크면 역시 scope error이기 때문에 오류 발생
- 이러한 오류가 발생하지 않을 때 비로소 세그먼트가 시작하는 위치 base에서 offset의 크기 d를 더한 주소로 이동해 주소 변환을 진행

**메모리 보호 기법**

- 각 세그먼트 별로 보호 비트가 있음
    - 보호 비트는 각 세그먼트에 대해 읽기/쓰기/실행 등의 권한이 있는 지를 나타낸다.
- 각 세그먼트 별로 유효 비트가 있음
    - 유효 비트는 각 세그먼트의 주소 변환 정보가 유효한지, 즉 해당 세그먼트가 현재 물리적 메모리에 적재되어 있는 지를 나타냄

**공유 세그먼트**

- 여러 프로세스가 특정 세그먼트를 공유하여 사용하는 개념
- 공유 세그먼트는 이 세그먼트를 공유하는 모든 프로세스의 주소 공간에서 동일한 논리적 주소에 위치해야 함

## 3. 세그먼테이션의 장점과 단점

**장점**

- 세그먼트는 의미 단위로 나누어져 있기 때문에 공유와 보안의 측면에서 페이징 기법에 비해 훨씬 효과적 
- 의미 단위로 세그먼트를 나누기 때문에 Read/Write 등을 구분하는게 자연스러움

**단점**

- 세그먼테이션 기법에서는 프로그램을 의미 단위로 나누기 때문에 세그먼트의 길이가 균일 X -> 물리적 메모리 관리에서 외부 단편화가 발생하게 되며, 연속 할당 메모리 관리의 가변 분할 방식에서의 동일한 문제점이 발생

## 4. 페이지드 세그먼테이션

- 페이지드 세그먼테이션 기법은 프로그램을 의미 단위의 세그먼트로 나누되, 세그먼트가 동일한 크기 페이지의 집합으로 구성
    - 즉 페이지드 세그먼테이션 기법에서는 하나의 세그먼트 크기를 페이지 크기의 배수가 되도록 함으로써 세그먼테이션 기법에서 발생하는 외부 단편화의 문제를 해결하며, 동시에 세그먼트 단위로 프로세스 간의 공유나 프로세스 내의 접근 권한 보호가 이루어지도록 함으로써 페이징 기법의 약점을 해소
- 주소 변환을 위해 외부의 세그먼트 테이블과 내부의 페이지 테이블, 이렇게 두 단계의 테이블을 이용
    - 하나의 세그먼트가 여러 개의 페이지로 구성되므로 각 세그먼트마다 페이지 테이블을 가지게 되는데, 2단계 페이지 테이블과 유사한 구조
- 단점: 세그먼트와 페이지가 동시에 존재하기 때문에 주소 변환도 두번해야함