# File

> 저장 장치에 연관된 정보의 논리적 저장 단위
> 
- 주소를 통해 접근하는 메모리처럼 이름을 통해 관련 데이터에 접근하는 논리적 저장 단위. 일반적으로 파일은 비휘발성 보조기억장치(ex.하드 디스크)에 저장
- 파일은 데이터를 저장하는 목적으로만 사용하는 게 아니다
    
    ⇒ OS: 다양한 저장 장치를 file이라는 동일한 논리적 단위로 관리
    
    ### 파일 연산
    
    - create
    - read
    - write
    - delete
    - reposition(lseek)
        
        : 필요에 따라 파일 시작 부분, 현재 위치 포인터 부분 말고 다른 부분부터 read/write 하고 싶은 경우에 현재 접근 위치를 변형해주는 것이 repostion 연산이다.
        
    - open
        
        : read, write를 하려면 open이 선행되어야 한다.
        
        - open의 역할은 해당 파일의 내용이 아닌 메타데이터를 디스크에서 메모리로 올리는 일이다.
    - close
        
        : 작업이 남아있지 않다면 close를 해주어야야한다.
        
        **왜 open, close가 따로 정의되어 있는가?**
        
        ⇒ [Open()](https://www.notion.so/Open-797944c2f27b4fcea109b9cf79cf5193) 
        

### 파일의 메타데이터

: 파일 자체의 내용과 관련 없이 파일을 관리하기 위한 각종 정보들

- ex 1. 음악 파일
    
    파일 자체의 내용 = 음악
    
    메타 데이터 = 이름, 유형, 디스크 상 저장 위치, 사이즈 등
    
- ex 2. 사진 파일
    
    파일 자체 내용 = 사진
    
    메타 데이터 = 파일 이름, 파일 접근 권한, 파일 생성 시간 등
    


### 파일 시스템

: 운영체제에서 파일을 관리하는 소프트웨어 부분

- 파일 저장 및 관리 방법 (어떻게 저장하고 어떻게 관리할 지), 파일의 보호 등을 담당
    - 파일 자체 내용뿐만 아니라 ****해당 파일의 메타 데이터도 같이 저장하며, **디렉토리**라는 걸 따로 둬서 **루트 디렉토리로부터 계층적으로 저장**할 수 있도록 구현되어 있다.

# Directory and Logical Disk

### Directory

> 디렉토리 밑에 있는 파일들이 무엇이며, 각각에 해당하는 정보(메타 데이터)가 무엇인지 내용으로 담고 있는 파일
> 
- 디렉토리에 메타 데이터를 몽땅 저장할 수도 있지만 해당 디렉토리 밑에 있는 일부 메타 데이터만 디렉토리에다가 직접 저장하고 일부는 다른 곳에다가 저장할 수 있다. (그러는 이유는 뒤에서 설명)
- 디렉토리 연산
    - 파일 목록을 보는 것
    - 파일을 찾는 것
    - 파일 생성, 삭제
    - 파일 이름 변경
    - 파일 시스템 전체 탐색 (traverse the file system)

### Partition(=Logical Disk)

> 운영체제가 바라보는 디스크
> 

파일 시스템은 하드 디스크에 저장된다. 디스크는 물리적, 논리적 디스크로 구분 가능한데, 운영체제가 바라 보는 디스크는 논리적인 디스크이며 partition이라고 부른다.

- 하드 디스크를 하나 구매한 후 C 드라이브, D 드라이브로 나누어 사용 ⇒ 하나의 물리적 디스크를 여러개의 논리적 디스크 (파티션) 구성하여 사용하는 것
    - 하나의 물리적 디스크 안에 여러 파티션을 구성하는 게 일반적
    - 여러개의 물리적인 디스크를 하나의 파티션으로 구성하기도 함
    - 파티션마다 독립적으로 파일 시스템 적용이 가능하며, Swap area 용도로도 사용할 수 있음.

# Open()

> 파일의 메타 데이터를 메모리에 올려두는 기능
> 
- 파티션 안에 파일 시스템이 있다면
    - 특정 파일의 메타 데이터 + 내용 저장
    - 내용을 가리키는 포인터도 같이 저장
    
    ⇒ 파일을 오픈하면 해당 파일의 메타 데이터가 메모리로 올라옴
    

**`open(/a/b/c)`**

/a/b/c 를 오픈 ⇒ c의 메타 데이터가 메모리로 올라온다.

→ 디렉토리 경로가 계층적으로 구성되어 있을 때 c라는 파일의 메타 데이터가 어디 저장되어 있는지부터 디스크에서 찾아야 한다.

- **찾는 방식**
    
    보통 **루트 디렉토리의 위치는 잘 알려져 있기 때문에** 루트 디렉토리부터 경로를 따라 내려가면서 c라는 파일의 위치를 찾는다.
    

### Open()이 진행되는 방식

<img src ="https://github.com/dongkiid/CS-Study/assets/113974911/891bb730-e994-460e-9f3e-9aa5eb81271d">

- (좌)물리적 메모리 (우)논리적 메모리
    - 커널 영역과 사용자 메모리 영역 가지고 있음
    - 사용자 프로그램이 시스템 콜을 할 수 있다. (read, write, open …)
        - 시스템콜을 할 경우 CPU 제어권이 운영체제로 넘어감
            
            운영체제 안에는 각 프로세스별로 관리하기 위한 자료구조가 있고, 전체 프로그램들이 오픈한 파일이 무엇인지 관리하는 글로벌한 테이블이 유지되고 있음.
            
            **진행 순서**
            
            1. 메타 데이터 메모리 올리기
            
            <img src = "https://github.com/dongkiid/CS-Study/assets/113974911/5b8c26d3-fd82-4673-965c-ff8a19a8b055">
            
            루트 디렉토리는 보통 운영체제가 미리 알고 있으므로, 루트 디렉토리의 메타데이터를 먼저 메모리에 올린다 ⇒ 루트 디렉토리의 메타데이터에는 하위  파일들의 메타데이터가 저장되어 있기에 a의 메타데이터도 메모리에 올린다 ⇒ 마찬가지로 a의 메타데이터에 하위 파일들의 메타데이터가 저장되어있기에 거기서 찾은 b의 메타데이터를 메모리에 올린다. 
            
            2. open()이 끝난 후 file descriptor 반환 
            
           <img src="https://github.com/dongkiid/CS-Study/assets/113974911/5b8c26d3-fd82-4673-965c-ff8a19a8b055">
            
            시스템콜이기에 결괏 값을 리턴하는데, 각 프로세스마다 그 프로세스가 오픈한 파일들에 대한 메타 데이터 포인터(=file descriptor, fd라고 줄여서 표현하겠다.)를 가지고 있는 일종의 정의된 배열안에서 해당 fd를 프로세스에게 리턴한다.  
            
            ⇒ 이제 b의 메타데이터가 fd가 가지고 있기 때문에, 프로세스는 fd만 가지고 read,write 요청이 가능하다! 
            
            open()이 끝난 뒤, read요청을 하면?
            
            <img src ="https://github.com/dongkiid/CS-Study/assets/113974911/d5c62bc5-b2a2-4449-bef6-086b0091ad6c">
            
            read는 시스템 콜이기에 CPU가 OS에게 넘어가고 프로세스의 pcb에 가서 해당 descriptor에 대응하는 메타 데이터 부분을 찾아서 파일의 디스크 위치 정보를 알아낸다.
            
            <img src ="https://github.com/dongkiid/CS-Study/assets/113974911/f518e6e6-d239-4aa1-b94b-989e54164998">
            
            ⇒ 시작 위치부터 요청한 용량만큼을 읽어오는데, 그 내용을 메모리로 읽어서 사용자 프로그램에게 직접 전달해주는 게 아닌, OS가 자신의 메모리 공간 일부(버퍼 캐시)에 먼저 읽어두고 사용자 프로그램에게 내용을 카피해서 전달한다.
            
            - ❓ 왜 운영체제는 read에 대한 응답 내용을 **버퍼 캐시**로 읽어들이고, 해당 내용을 프로그램으로 복사해서 전달할까?
                
                = **디스크에 직접 액세스 하는 작업 횟수를 줄이기 위해!**
                
                읽어들인 내용과 연관된 후속 요청이 들어올 경우, 파일 시스템에 다시 접근할 필요 없이 버퍼 혹은 캐시에 저장된 내용에서 카피를 떠서 주면 됨 ⇒ 디스크 I/O 비용 줄이고, 응답 속도 향상 가능/ 중복 디스크 액세스를 피해 데이터 일관성 유지 가능
                
                ⇒**모든 정보를 OS가 알고 있기 때문에 버퍼 캐시 환경에서는 LRU, LFU 알고리즘을 자연스럽게 사용 가능합니다. → 페이징 시스템의 클락 알고리즘과는 대조적**
                
        - 커널이 가지고 있는 테이블들의 특징
        
        <img src ="https://github.com/dongkiid/CS-Study/assets/113974911/cd13efdd-9da8-448c-9b47-e028c6277e43">
        
        **per-process file descriptor table**
        
        - 파일 descriptor 테이블은 **프로세스마다** 가지고 있다고 해서 저렇게 부름
        
        **open file table**
        
        - 파일을 오픈했을 때는 프로세스마다 가지고 있는게 아니라 **오픈된 파일의 목록들을 시스템에서 와이드하게 관리하는 것**이기 때문에 시스템 전체에 하나 존재하는 open file table이라고 부름
    
    <aside>
    💡 메타 데이터가 디스크에 있을 때는 file attribute(파일에 관련된 추가적인 정보)만이 메타 데이터가 되는데 메모리로 올려놓게 되면 추가적인 한 가지 메타데이터가 더 필요하게 된다. → **파일의 어느 위치를 접근하고 있는지에 대한 offset**
    
    </aside>
    
    ### offset
    
    > 파일 내에서 어느 위치에 접근하고 있는 지에 대한 정보
    > 
    
    만약 a라는 프로그램이 해당 파일을 open했다고 하면 다른 프로그램도 이 파일을 오픈할 수 있다. b라는 메타 데이터는 메모리에 시스템 와이드하게 하나만 존재하지만 offset은 서로 다를 수 있다.
    
    그래서 open file table은 2개로 나눠서 관리할 수 있다.
    
    1. 프로세스와 무관하게 하나만 가지면 되는 메타 데이터
    2. 별도로 가지고 있어야 하는 offset
    
    PCB는 메타 데이터 위치만 가르키는 포인터이기 때문에 내용을 가지지 않아서 나눌 필요 없음.
    

# File Protection

> 하나의 파일을 여러 사용자, 여러 프로그램이 공유할 수 있기 때문에 **접근 권한은 누구한테 있는지, 어떤 연산을 가능하게 했는 지**에 대한 정보를 같이 가지고 있어야 함
> 

### 접근 권한 제어 방법

1. Access Control Matrix
    
    행렬의 행과 열에 사용자, 파일 이름을 나열해두고 각각의 사용자가 각각의 파일에 대해서 어떤 권한이 있는지 표시해두는 방식
    
    - 특정 사용자가 특정 파일에 대해 접근했을 때 권한이 있는 지 체크하고 권한이 있으면 허용
    - 행렬 자체가 **희소 행렬(**값이 대부분 0인 행렬) **형태**가 될 것
        - 파일들은 엄청 많지만 특정 사용자가 본인만 사용하려고 만든 건 다른 사용자들이 접근할 권한이 전혀 없기 때문에 값이 0으로 설정된 부분이 다수일 가능성이 있다.
            
            ⇒ 행렬의 칸을 다 만들면 낭비
            
    - 모든 사용자에 대해 모든 파일의 접근 권한을 제어하는 것이 가능
        - but, 부가적인 오버헤드가 크기에 사용이 어려움
        
2. **Grouping (일반적으로 사용)**
    
    각 파일에 대해서 사용자 그룹을 owner, group, public으로 나누고 세 그룹에 대한 접근 권한(rwx)을 표시
    
    - 모든 사용자에 대해서 접근 권한을 나타내지 않기 때문에 일반적으로 사용
    - 접근 권한을 나타내기 위해서는 총 9개의 비트만 있으면 가능
    - 권한이 있다면 1, 없다면 0으로 나타냄
    - 굉장히 효율적
    
3. Password
    
    모든 파일에 대해서 비밀번호로 관리하는 방식입니다.
    
    - 파일, 디렉토리에 대해서 비밀번호 걸고 접근하려면 비밀번호를 풀어야 함
    - 모든 권한에 대해 하나의 비밀번호가 존재
    - 패스워드가 굉장히 많이 생기고 기억하기 어려워짐
    - 어디다가 써놓으면 보안에 안좋음.

---

하나의 물리적인 디스크는 여러 개의 논리적인 디스크로 나눌 수 있고 각 논리적인 디스크는 파일 시스템을 설치해서 사용할 수 있다.

다른 파티션에 있는 파일 시스템에 접근하고 싶은 경우에는 어떻게 해야할까?

⇒ Mounting을 사용하면 된다!

# Mounting

> 루트 파일 시스템의 특정 디렉토리 이름에다 또 다른 파티션에 있는 파일 시스템을 가져다 마운트를 해주는 행위
> 

⇒ 마운트된 디렉토리를 접근하게 되면 **또다른 파일 시스템의 루트 디렉토리를 접근**해서 서로 다른 파티션에 접근할 수 있게 된다.

# Access Method

### 파일 접근 방법

1. 순차 접근
- 카세트 테이프, 비디오 테이프 → 순차 접근만 가능
1. 직접 접근(임의 접근)
- CD, 하드 디스크, LP판과 같이 접근 → 직접 접근 가능한 매체
- 특정 위치를 접근한 다음에 다른 위치 바로 접근 가능

매체에 따라서 직접 접근만 되는 매체가 있고 아닌 매체가 있다. 관리를 어떻게 하는가에 따라서 순차 접근만 가능한 경우도 존재한다.

**해당 내용은 다음 챕터에서 배워보자~!**
